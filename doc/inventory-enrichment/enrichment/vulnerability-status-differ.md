> [Vulnerability Monitoring](../inventory-enrichment-overview.md) > Inventory Vulnerability Status differ

# Inventory Vulnerability Status differ

The `com.metaeffekt.artifact.analysis` : `ae-inventory-enrichment-plugin` : `vulnerability-differ` goal allows for
comparing two sets of one or more inventories with each other.

## Example configuration

```xml

<configuration>
    <referenceInventories1>
        <file>/Users/.../inventory-enriched-1.xls</file>
    </referenceInventories1>
    <referenceInventories2>
        <file>/Users/.../inventory-enriched-2.xls</file>
    </referenceInventories2>

    <outputInventoryDiff1to2>
        /Users/.../1-2.xls
    </outputInventoryDiff1to2>
    <outputInventoryDiff2to1>
        /Users/.../2-1.xls
    </outputInventoryDiff2to1>
</configuration>
```

## Resulting format

The inventories produced by the differ contain only the `Vulnerabilities` sheet. The sheet contains the following
columns:

- `Name`: The vulnerability identifier
- `Status`: The status of the vulnerability in the first inventory
- `New Status`: The status of the vulnerability in the second inventory
- `Status change`: A label that describes the change of the status from the first to the second inventory. See below for
  more information.
- `CVSS Unmodified Overall (max)`: The latest CVSS unmodified score
- `CVSS Modified Overall (max)`: The latest CVSS modified score
- `CVSS Unmodified Severity (max)`: The latest CVSS unmodified severity
- `CVSS Modified Severity (max)`: The latest CVSS modified severity
- `Product URIs`: The effective Product URIs (CPEs) of the vulnerability

The `Status` and `New Status` columns may not be empty, so they are filled with `n/a` if the vulnerability does not
exist in the respective inventory, and `in review` when the vulnerability is present but has no status.

The vulnerability status in the inventories is set using the
[Vulnerability Status enrichment step](https://github.com/org-metaeffekt/metaeffekt-documentation-template/blob/main/doc/inventory-enrichment/enrichment/steps.md#vulnerability-status).

Generally, if a vulnerability has had a status once, it should keep it throughout its lifetime. The status changes below
will show this, as all whenever information is `lost` by removing a status, a negatively worded label is used.

## Status change explanation

The `Status change` label is determined based on the presence of the vulnerability in the inventories and its status:

- If the vulnerability is not contained in any of the inventories, the entire process fails.
- If the vulnerability is only contained in the first inventory, meaning it has been removed to the second inventory:
    - use `removed (expected void)` :x: if the vulnerability has had a status in the first inventory
    - use `removed` :small_blue_diamond: if the vulnerability has had no status in the first inventory
- If the vulnerability is only known to the second inventory, use `new` :boom:.
- If the vulnerability is in both inventories, use the following table:

| New Status \ Old Status | applicable                             | not applicable                         | insignificant                          | void                        | null                                 |
|-------------------------|----------------------------------------|----------------------------------------|----------------------------------------|-----------------------------|--------------------------------------|
| applicable              | :fast_forward: _no change_             | :small_red_triangle_down: downrated    | :small_red_triangle_down: downrated    | :white_check_mark: resolved | :heavy_exclamation_mark: **invalid** |
| not applicable          | :small_red_triangle: uprated           | :fast_forward: _no change_             | :small_red_triangle_down: downrated    | :white_check_mark: resolved | :heavy_exclamation_mark: **invalid** |
| insignificant           | :small_red_triangle: uprated           | :small_red_triangle: uprated           | :fast_forward: _no change_             | :white_check_mark: resolved | :heavy_exclamation_mark: **invalid** |
| void                    | :arrows_counterclockwise: reintroduced | :arrows_counterclockwise: reintroduced | :arrows_counterclockwise: reintroduced | :fast_forward: _no change_  | :heavy_exclamation_mark: **invalid** |
| null                    | :boom: introduced                      | :boom: introduced                      | :boom: introduced                      | :boom: introduced           | :fast_forward: _no change_           |

The individual status changes are explained below.

### no change :fast_forward:

This label is assigned when a vulnerability is present in both inventories and its status remains unchanged. This
indicates that the vulnerability's impact level has not changed between the two inventories.

### downrated :small_red_triangle_down:

This label is assigned when a vulnerability is present in both inventories and its status changes from a higher severity
level to a lower one. This indicates a decrease in the impact level of the vulnerability in the new inventory.

### uprated :small_red_triangle:

This label is assigned when a vulnerability is present in both inventories and its status changes from a lower severity
level to a higher one. This indicates an increase in the impact level of the vulnerability in the new inventory.

### resolved :white_check_mark:

This label is assigned when a vulnerability is present in both inventories and its status changes to "void" in the new
inventory. This means that the vulnerability was not matched by the enrichment algorithm and was therefore not present
in the inventory, before a status file for the vulnerability caused it to be added to the inventory and have the status
"void" assigned.

### invalid :heavy_exclamation_mark:

If a vulnerability has no more status, but still exists in the new inventory, the label "invalid" is assigned. This
should never be the case, as the name "invalid" already suggests: If a vulnerability is still present in the new
inventory and had a status in the old inventory, it should still have a status in the new inventory. You should check
what happened to the status file for the vulnerability to prevent the loss of information.

### reintroduced :arrows_counterclockwise:

This label is assigned when a vulnerability's status changes from "void" to any other status in the new inventory. This
indicates that a previously addressed vulnerability has reappeared in the new inventory.

### introduced :boom:

This label is assigned when a vulnerability was present in the old inventory without a status, but appears in the new
inventory with any status. This means, it had the status change "new" once, but now has a status other than none,
meaning it was assessed for the first time.

### removed (expected void) :x:

This label is assigned when a vulnerability is present in the old inventory but not in the new one, and it had a status
in the old inventory. This indicates that the vulnerability was expected to be addressed in the new inventory, but was
not. You should however create a status file for the vulnerability to prevent the loss of information.

### removed :small_blue_diamond:

This label is assigned when a vulnerability is present in the old inventory but not in the new one, and it had no status
in the old inventory. No additional action is necessary, as the vulnerability was never inspected to begin with.

### new :boom:

This label is assigned when a vulnerability is not present in the old inventory but appears in the new one. For this, it
does not matter what status the vulnerability has in the new inventory.

## Implementation details

The process of comparing and merging vulnerability data involves several steps:

1. Parse all inventories from the provided files into two lists.
2. Merge the lists into one inventory each, only keeping the `Vulnerabilities` sheet.
3. For each pair of merged inventories (1 --> 2 and 2 --> 1):
    1. Build a superset of all vulnerability identifiers from both merged inventories.
    2. For each vulnerability identifier:
        1. Find a vulnerability with the exact identifier in both inventories, if available.
        2. Parse the `Status` from both vulnerabilities, if available.
        3. Build a combined vulnerability that contains the identifier, old and new status, and the status change label.
    3. Create a new inventory from the combined vulnerabilities and write it to the output file.
